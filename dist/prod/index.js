!function(){var e="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{};function r(e){return e&&e.__esModule?e.default:e}var s={},t={},n=e.parcelRequire7e6a;null==n&&((n=function(e){if(e in s)return s[e].exports;if(e in t){let r=t[e];delete t[e];let n={id:e,exports:{}};return s[e]=n,r.call(n.exports,n,n.exports),n.exports}var r=new Error("Cannot find module '"+e+"'");throw r.code="MODULE_NOT_FOUND",r}).register=function(e,r){t[e]=r},e.parcelRequire7e6a=n),n.register("4KHtv",(function(e,r){!function(s,t){if("function"==typeof define&&define.amd)define("webextension-polyfill",["module"],t);else if(void 0!==r)t(e);else{var n={exports:{}};t(n),s.browser=n.exports}}("undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:this,(function(e){"use strict";if("undefined"==typeof browser||Object.getPrototypeOf(browser)!==Object.prototype){const r="The message port closed before a response was received.",s="Returning a Promise is the preferred way to send a reply from an onMessage/onMessageExternal listener, as the sendResponse will be removed from the specs (See https://developer.mozilla.org/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage)",t=e=>{const t={alarms:{clear:{minArgs:0,maxArgs:1},clearAll:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getAll:{minArgs:0,maxArgs:0}},bookmarks:{create:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},getChildren:{minArgs:1,maxArgs:1},getRecent:{minArgs:1,maxArgs:1},getSubTree:{minArgs:1,maxArgs:1},getTree:{minArgs:0,maxArgs:0},move:{minArgs:2,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeTree:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}},browserAction:{disable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},enable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},getBadgeBackgroundColor:{minArgs:1,maxArgs:1},getBadgeText:{minArgs:1,maxArgs:1},getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},openPopup:{minArgs:0,maxArgs:0},setBadgeBackgroundColor:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setBadgeText:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},browsingData:{remove:{minArgs:2,maxArgs:2},removeCache:{minArgs:1,maxArgs:1},removeCookies:{minArgs:1,maxArgs:1},removeDownloads:{minArgs:1,maxArgs:1},removeFormData:{minArgs:1,maxArgs:1},removeHistory:{minArgs:1,maxArgs:1},removeLocalStorage:{minArgs:1,maxArgs:1},removePasswords:{minArgs:1,maxArgs:1},removePluginData:{minArgs:1,maxArgs:1},settings:{minArgs:0,maxArgs:0}},commands:{getAll:{minArgs:0,maxArgs:0}},contextMenus:{remove:{minArgs:1,maxArgs:1},removeAll:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},cookies:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:1,maxArgs:1},getAllCookieStores:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},devtools:{inspectedWindow:{eval:{minArgs:1,maxArgs:2,singleCallbackArg:!1}},panels:{create:{minArgs:3,maxArgs:3,singleCallbackArg:!0},elements:{createSidebarPane:{minArgs:1,maxArgs:1}}}},downloads:{cancel:{minArgs:1,maxArgs:1},download:{minArgs:1,maxArgs:1},erase:{minArgs:1,maxArgs:1},getFileIcon:{minArgs:1,maxArgs:2},open:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},pause:{minArgs:1,maxArgs:1},removeFile:{minArgs:1,maxArgs:1},resume:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},extension:{isAllowedFileSchemeAccess:{minArgs:0,maxArgs:0},isAllowedIncognitoAccess:{minArgs:0,maxArgs:0}},history:{addUrl:{minArgs:1,maxArgs:1},deleteAll:{minArgs:0,maxArgs:0},deleteRange:{minArgs:1,maxArgs:1},deleteUrl:{minArgs:1,maxArgs:1},getVisits:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1}},i18n:{detectLanguage:{minArgs:1,maxArgs:1},getAcceptLanguages:{minArgs:0,maxArgs:0}},identity:{launchWebAuthFlow:{minArgs:1,maxArgs:1}},idle:{queryState:{minArgs:1,maxArgs:1}},management:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},getSelf:{minArgs:0,maxArgs:0},setEnabled:{minArgs:2,maxArgs:2},uninstallSelf:{minArgs:0,maxArgs:1}},notifications:{clear:{minArgs:1,maxArgs:1},create:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:0},getPermissionLevel:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},pageAction:{getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},hide:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},permissions:{contains:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},request:{minArgs:1,maxArgs:1}},runtime:{getBackgroundPage:{minArgs:0,maxArgs:0},getPlatformInfo:{minArgs:0,maxArgs:0},openOptionsPage:{minArgs:0,maxArgs:0},requestUpdateCheck:{minArgs:0,maxArgs:0},sendMessage:{minArgs:1,maxArgs:3},sendNativeMessage:{minArgs:2,maxArgs:2},setUninstallURL:{minArgs:1,maxArgs:1}},sessions:{getDevices:{minArgs:0,maxArgs:1},getRecentlyClosed:{minArgs:0,maxArgs:1},restore:{minArgs:0,maxArgs:1}},storage:{local:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},managed:{get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1}},sync:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}}},tabs:{captureVisibleTab:{minArgs:0,maxArgs:2},create:{minArgs:1,maxArgs:1},detectLanguage:{minArgs:0,maxArgs:1},discard:{minArgs:0,maxArgs:1},duplicate:{minArgs:1,maxArgs:1},executeScript:{minArgs:1,maxArgs:2},get:{minArgs:1,maxArgs:1},getCurrent:{minArgs:0,maxArgs:0},getZoom:{minArgs:0,maxArgs:1},getZoomSettings:{minArgs:0,maxArgs:1},goBack:{minArgs:0,maxArgs:1},goForward:{minArgs:0,maxArgs:1},highlight:{minArgs:1,maxArgs:1},insertCSS:{minArgs:1,maxArgs:2},move:{minArgs:2,maxArgs:2},query:{minArgs:1,maxArgs:1},reload:{minArgs:0,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeCSS:{minArgs:1,maxArgs:2},sendMessage:{minArgs:2,maxArgs:3},setZoom:{minArgs:1,maxArgs:2},setZoomSettings:{minArgs:1,maxArgs:2},update:{minArgs:1,maxArgs:2}},topSites:{get:{minArgs:0,maxArgs:0}},webNavigation:{getAllFrames:{minArgs:1,maxArgs:1},getFrame:{minArgs:1,maxArgs:1}},webRequest:{handlerBehaviorChanged:{minArgs:0,maxArgs:0}},windows:{create:{minArgs:0,maxArgs:1},get:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:1},getCurrent:{minArgs:0,maxArgs:1},getLastFocused:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}}};if(0===Object.keys(t).length)throw new Error("api-metadata.json has not been included in browser-polyfill");class n extends WeakMap{constructor(e,r){super(r),this.createItem=e}get(e){return this.has(e)||this.set(e,this.createItem(e)),super.get(e)}}const a=(r,s)=>(...t)=>{e.runtime.lastError?r.reject(e.runtime.lastError):s.singleCallbackArg||t.length<=1&&!1!==s.singleCallbackArg?r.resolve(t[0]):r.resolve(t)},o=e=>1==e?"argument":"arguments",i=(e,r,s)=>new Proxy(r,{apply:(r,t,n)=>s.call(t,e,...n)});let g=Function.call.bind(Object.prototype.hasOwnProperty);const m=(e,r={},s={})=>{let t=Object.create(null),n={has:(r,s)=>s in e||s in t,get(n,l,A){if(l in t)return t[l];if(!(l in e))return;let c=e[l];if("function"==typeof c)if("function"==typeof r[l])c=i(e,e[l],r[l]);else if(g(s,l)){let r=((e,r)=>function(s,...t){if(t.length<r.minArgs)throw new Error(`Expected at least ${r.minArgs} ${o(r.minArgs)} for ${e}(), got ${t.length}`);if(t.length>r.maxArgs)throw new Error(`Expected at most ${r.maxArgs} ${o(r.maxArgs)} for ${e}(), got ${t.length}`);return new Promise(((n,o)=>{if(r.fallbackToNoCallback)try{s[e](...t,a({resolve:n,reject:o},r))}catch(a){console.warn(`${e} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `,a),s[e](...t),r.fallbackToNoCallback=!1,r.noCallback=!0,n()}else r.noCallback?(s[e](...t),n()):s[e](...t,a({resolve:n,reject:o},r))}))})(l,s[l]);c=i(e,e[l],r)}else c=c.bind(e);else if("object"==typeof c&&null!==c&&(g(r,l)||g(s,l)))c=m(c,r[l],s[l]);else{if(!g(s,"*"))return Object.defineProperty(t,l,{configurable:!0,enumerable:!0,get:()=>e[l],set(r){e[l]=r}}),c;c=m(c,r[l],s["*"])}return t[l]=c,c},set:(r,s,n,a)=>(s in t?t[s]=n:e[s]=n,!0),defineProperty:(e,r,s)=>Reflect.defineProperty(t,r,s),deleteProperty:(e,r)=>Reflect.deleteProperty(t,r)},l=Object.create(e);return new Proxy(l,n)},l=e=>({addListener(r,s,...t){r.addListener(e.get(s),...t)},hasListener:(r,s)=>r.hasListener(e.get(s)),removeListener(r,s){r.removeListener(e.get(s))}});let A=!1;const c=new n((e=>"function"!=typeof e?e:function(r,t,n){let a,o,i=!1,g=new Promise((e=>{a=function(r){A||(console.warn(s,(new Error).stack),A=!0),i=!0,e(r)}}));try{o=e(r,t,a)}catch(e){o=Promise.reject(e)}const m=!0!==o&&((l=o)&&"object"==typeof l&&"function"==typeof l.then);var l;if(!0!==o&&!m&&!i)return!1;const c=e=>{e.then((e=>{n(e)}),(e=>{let r;r=e&&(e instanceof Error||"string"==typeof e.message)?e.message:"An unexpected error occurred",n({__mozWebExtensionPolyfillReject__:!0,message:r})})).catch((e=>{console.error("Failed to send onMessage rejected reply",e)}))};return c(m?o:g),!0})),d=({reject:s,resolve:t},n)=>{e.runtime.lastError?e.runtime.lastError.message===r?t():s(e.runtime.lastError):n&&n.__mozWebExtensionPolyfillReject__?s(new Error(n.message)):t(n)},x=(e,r,s,...t)=>{if(t.length<r.minArgs)throw new Error(`Expected at least ${r.minArgs} ${o(r.minArgs)} for ${e}(), got ${t.length}`);if(t.length>r.maxArgs)throw new Error(`Expected at most ${r.maxArgs} ${o(r.maxArgs)} for ${e}(), got ${t.length}`);return new Promise(((e,r)=>{const n=d.bind(null,{resolve:e,reject:r});t.push(n),s.sendMessage(...t)}))},u={runtime:{onMessage:l(c),onMessageExternal:l(c),sendMessage:x.bind(null,"sendMessage",{minArgs:1,maxArgs:3})},tabs:{sendMessage:x.bind(null,"sendMessage",{minArgs:2,maxArgs:3})}},f={clear:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}};return t.privacy={network:{"*":f},services:{"*":f},websites:{"*":f}},m(e,u,t)};if("object"!=typeof chrome||!chrome||!chrome.runtime||!chrome.runtime.id)throw new Error("This script should only be loaded in a browser extension.");e.exports=t(chrome)}else e.exports=browser}))}));var a=n("4KHtv");let o=!1;e.browser=r(a);const i=browser.runtime.getManifest().version;window.eval(`window.point = (${((e,r)=>{class s extends Error{}class t extends Error{}class n extends Error{}class a extends Error{}class i extends Error{}class g extends Error{}const m=async(r,t)=>{try{const n=await window.top.fetch(`${e}/v1/api/${r}`,{cache:"no-cache",credentials:"include",keepalive:!0,...t,headers:{"Content-Type":"application/json",...t?.headers}});if(!n.ok){const{ok:e,status:r,statusText:t,headers:a}=n;throw console.error("SDK call failed:",{ok:e,status:r,statusText:t,headers:Object.fromEntries([...a.entries()])}),new s("Point SDK request failed")}try{return await n.json()}catch(e){throw console.error("Point API response parsing error:",e),e}}catch(e){throw console.error("Point API call failed:",e),e}},l={get:(e,r,s)=>m(`${e}${r?"?":""}${new URLSearchParams(r).toString()}`,{method:"GET",headers:s}),post:(e,r,s)=>m(e,{method:"POST",headers:s,body:JSON.stringify(r)}),postFile:(r,t)=>(async(r,t)=>{try{const n=await window.top.fetch(`${e}/${r}`,{cache:"no-cache",credentials:"include",keepalive:!0,...t});if(!n.ok){const{ok:e,status:r,statusText:t,headers:a}=n;throw console.error("SDK ZProxy call failed:",{ok:e,status:r,statusText:t,headers:Object.fromEntries([...a.entries()])}),new s("Point SDK request failed")}try{return await n.json()}catch(e){throw console.error("Point API response parsing error:",e),e}}catch(e){throw console.error("Point API call failed:",e),e}})(r,{method:"POST",body:t})};function A(e){return new Promise((r=>setTimeout(r,e)))}const c={},d={},x={},u="subscription_confirmation",f="subscription_cancellation",p="subscription_event",w="subscription_error",b="subscribeContractEvent",h="removeSubscriptionById",y=({type:e,params:{contract:r,event:s}={}})=>`${e}_${r}_${s}`,v=e=>d[e]||(d[e]=[]),k={},S=(e,{messageQueueSizeLimit:r=1e3}={})=>new Promise(((s,o)=>{if(void 0!==c[e])return void s(c[e]);const m=new WebSocket(e);m.onopen=()=>s(Object.assign(c[e]=m,{async subscribeToContractEvent(e){const r={type:b,params:e},s=y(r);k[s]=function(){let e=()=>{},r=()=>{};return Object.assign(new Promise(((s,t)=>{e=s,r=t})),{resolve:e,reject:r})}(),await m.send(JSON.stringify(r));const t=await Promise.race([k[s],(n=1e4,new Promise(((e,r)=>setTimeout((()=>r(new i("Subscription confirmation timeout"))),n))))]);var n;const a=v(t);return Object.assign((async()=>{for(;;)try{const e=x[t];if(e)throw e;if(a.length)return a.shift();await A(100)}catch(e){throw console.error("subscribed message error:",e),e}}),{unsubscribe:()=>m.send(JSON.stringify({type:h,params:{subscriptionId:t}}))})}})),m.onerror=e=>{for(const r in d)x[r]||(x[r]=new n(e.toString()))},m.onclose=r=>{delete c[e];for(const e in d)x[e]||(x[e]=new a(r.toString()));1e3===r.code?s(void 0):o()},m.onmessage=e=>{try{const{type:s,request:n,subscriptionId:a,data:o}=JSON.parse(e.data);switch(s){case u:{const e=y(n),{resolve:r,reject:s}=k[e]||{};"string"!=typeof a?"function"==typeof s&&s(new g(`Invalid subscription id "${a}" for request id: "${e}"`)):"function"==typeof r&&r(a);break}case f:a&&(console.info({type:s,request:n,subscriptionId:a,data:o}),delete d[a],delete x[a]);break;case p:if(a){const e=v(a);e.length>r?x[a]=new t("ZProxy WS message queue overflow"):e.push(o)}else console.error("Unable to identify subscription channel",{subscriptionId:a,request:n,data:o});break;case w:a?x[a]=new g(JSON.stringify(o)):console.error("Unable to identify subscription channel",{subscriptionId:a,request:n,data:o});break;default:console.error("Unsupported event type:",{type:s,request:n,subscriptionId:a,data:o})}}catch(e){console.log("Web Socket onmessage error:",e)}}}));return{version:r,status:{ping:()=>l.get("status/ping",void 0,{"wallet-token":"WALLETID-PASSCODE"})},contract:{load:({contract:e,...r})=>l.get(`contract/load/${e}`,r,{"wallet-token":"WALLETID-PASSCODE"}),call:e=>l.post("contract/call",e,{"wallet-token":"WALLETID-PASSCODE"}),send:e=>{if(!window.confirm(`This site is trying to send a transaction for the ${e.method} method for the ${e.contract} contract. Allow this action?`))throw alert("Transaction not sent"),new Error("Send method not allowed");if(!o)throw alert("Wallet access denied"),new Error("Wallet access denied");return l.post("contract/send",e,{"wallet-token":"WALLETID-PASSCODE"})},async subscribe({contract:r,event:t,...n}){if("string"!=typeof r)throw new s(`Invalid contract ${r}`);if("string"!=typeof t)throw new s(`Invalid event ${t}`);const a=new URL(e);a.protocol="https:"===a.protocol?"wss:":"ws:";const o=await S(a.toString());if(!o)throw new s("Failed to establish web socket connection");return o.subscribeToContractEvent({contract:r,event:t,...n})}},storage:{postFile:e=>l.postFile("_storage/",e),getString:({id:e,...r})=>l.get(`storage/getString/${e}`,r,{"wallet-token":"WALLETID-PASSCODE"}),putString:e=>l.post("storage/putString",e,{"wallet-token":"WALLETID-PASSCODE"})},wallet:{address:()=>{if(!window.confirm("Allow the site to access your wallet address?"))throw o=!1,alert("Wallet access denied"),new Error("Wallet access denied");return o=!0,window.alert("This site has access to your wallet address now"),l.get("wallet/address")},hash:()=>l.get("wallet/hash")},identity:{ownerToIdentity:({owner:e,...r})=>l.get(`identity/ownerToIdentity/${e}`,r,{"wallet-token":"WALLETID-PASSCODE"})}}}).toString()})(window.location.origin, '${i}');`)}();
//# sourceMappingURL=index.js.map
