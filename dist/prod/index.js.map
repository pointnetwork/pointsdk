{"mappings":"i2BAQI,oBAAOA,SAA2BC,OAAOC,eAAeF,WAAaC,OAAOE,UAAhF,OACQC,EAAgD,0DAChDC,EAAiC,yPAOjCC,EAAWC,UAITC,EAAW,QACf,OACE,SACa,UACA,YAEb,SACa,UACA,OAEb,SACa,UACA,UAEb,SACa,UACA,cAGf,QACE,SACa,UACA,OAEb,SACa,UACA,eAEb,SACa,UACA,aAEb,SACa,UACA,cAEb,SACa,UACA,WAEb,SACa,UACA,QAEb,SACa,UACA,UAEb,SACa,UACA,cAEb,SACa,UACA,UAEb,SACa,UACA,UAEb,SACa,UACA,kBAGf,SACE,SACa,UACA,wBACa,UAE1B,SACa,UACA,wBACa,2BAE1B,SACa,UACA,gBAEb,SACa,UACA,YAEb,SACa,UACA,YAEb,SACa,UACA,aAEb,SACa,UACA,2BAEb,SACa,UACA,wBACa,gBAE1B,SACa,UACA,wBACa,WAE1B,SACa,UACA,YAEb,SACa,UACA,wBACa,YAE1B,SACa,UACA,wBACa,iBAG5B,QACE,SACa,UACA,eAEb,SACa,UACA,iBAEb,SACa,UACA,mBAEb,SACa,UACA,kBAEb,SACa,UACA,iBAEb,SACa,UACA,sBAEb,SACa,UACA,mBAEb,SACa,UACA,oBAEb,SACa,UACA,YAEb,SACa,UACA,aAGf,QACE,SACa,UACA,iBAGf,QACE,SACa,UACA,aAEb,SACa,UACA,UAEb,SACa,UACA,YAGf,KACE,SACa,UACA,UAEb,SACa,UACA,sBAEb,SACa,UACA,UAEb,SACa,UACA,OAEb,SACa,UACA,aAGf,iBACE,MACE,SACa,UACA,qBACU,WAGzB,QACE,SACa,UACA,qBACU,YAEvB,mBACE,SACa,UACA,gBAKnB,QACE,SACa,UACA,YAEb,SACa,UACA,SAEb,SACa,UACA,eAEb,SACa,UACA,QAEb,SACa,UACA,wBACa,SAE1B,SACa,UACA,cAEb,SACa,UACA,UAEb,SACa,UACA,UAEb,SACa,UACA,QAEb,SACa,UACA,wBACa,cAG5B,2BACE,SACa,UACA,4BAEb,SACa,UACA,YAGf,QACE,SACa,UACA,aAEb,SACa,UACA,eAEb,SACa,UACA,aAEb,SACa,UACA,aAEb,SACa,UACA,UAEb,SACa,UACA,SAGf,gBACE,SACa,UACA,sBAEb,SACa,UACA,aAGf,mBACE,SACa,UACA,SAGf,YACE,SACa,UACA,eAGf,KACE,SACa,UACA,UAEb,SACa,UACA,WAEb,SACa,UACA,cAEb,SACa,UACA,iBAEb,SACa,UACA,kBAGf,OACE,SACa,UACA,UAEb,SACa,UACA,UAEb,SACa,UACA,sBAEb,SACa,UACA,UAEb,SACa,UACA,eAGf,UACE,SACa,UACA,YAEb,SACa,UACA,QAEb,SACa,UACA,wBACa,WAE1B,SACa,UACA,YAEb,SACa,UACA,wBACa,YAE1B,SACa,UACA,wBACa,QAE1B,SACa,UACA,wBACa,gBAG5B,UACE,SACa,UACA,UAEb,SACa,UACA,UAEb,SACa,UACA,WAEb,SACa,UACA,YAGf,mBACE,SACa,UACA,mBAEb,SACa,UACA,mBAEb,SACa,UACA,sBAEb,SACa,UACA,eAEb,SACa,UACA,qBAEb,SACa,UACA,mBAEb,SACa,UACA,aAGf,YACE,SACa,UACA,qBAEb,SACa,UACA,WAEb,SACa,UACA,YAGf,OACE,OACE,SACa,UACA,OAEb,SACa,UACA,iBAEb,SACa,UACA,UAEb,SACa,UACA,OAEb,SACa,UACA,YAGf,KACE,SACa,UACA,iBAEb,SACa,UACA,SAGf,OACE,SACa,UACA,OAEb,SACa,UACA,iBAEb,SACa,UACA,UAEb,SACa,UACA,OAEb,SACa,UACA,UAIjB,mBACE,SACa,UACA,UAEb,SACa,UACA,kBAEb,SACa,UACA,WAEb,SACa,UACA,aAEb,SACa,UACA,iBAEb,SACa,UACA,OAEb,SACa,UACA,cAEb,SACa,UACA,WAEb,SACa,UACA,mBAEb,SACa,UACA,UAEb,SACa,UACA,aAEb,SACa,UACA,aAEb,SACa,UACA,aAEb,SACa,UACA,QAEb,SACa,UACA,SAEb,SACa,UACA,UAEb,SACa,UACA,UAEb,SACa,UACA,aAEb,SACa,UACA,eAEb,SACa,UACA,WAEb,SA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","sources":["node_modules/webextension-polyfill/dist/browser-polyfill.js","src/pointsdk/index.ts","src/index.ts"],"sourcesContent":["/* webextension-polyfill - v0.7.0 - Tue Nov 10 2020 20:24:04 */\n/* -*- Mode: indent-tabs-mode: nil; js-indent-level: 2 -*- */\n/* vim: set sts=2 sw=2 et tw=80: */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\"use strict\";\n\nif (typeof browser === \"undefined\" || Object.getPrototypeOf(browser) !== Object.prototype) {\n  const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = \"The message port closed before a response was received.\";\n  const SEND_RESPONSE_DEPRECATION_WARNING = \"Returning a Promise is the preferred way to send a reply from an onMessage/onMessageExternal listener, as the sendResponse will be removed from the specs (See https://developer.mozilla.org/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage)\";\n\n  // Wrapping the bulk of this polyfill in a one-time-use function is a minor\n  // optimization for Firefox. Since Spidermonkey does not fully parse the\n  // contents of a function until the first time it's called, and since it will\n  // never actually need to be called, this allows the polyfill to be included\n  // in Firefox nearly for free.\n  const wrapAPIs = extensionAPIs => {\n    // NOTE: apiMetadata is associated to the content of the api-metadata.json file\n    // at build time by replacing the following \"include\" with the content of the\n    // JSON file.\n    const apiMetadata = {\n      \"alarms\": {\n        \"clear\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"clearAll\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"get\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"getAll\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        }\n      },\n      \"bookmarks\": {\n        \"create\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"get\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getChildren\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getRecent\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getSubTree\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getTree\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"move\": {\n          \"minArgs\": 2,\n          \"maxArgs\": 2\n        },\n        \"remove\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removeTree\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"search\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"update\": {\n          \"minArgs\": 2,\n          \"maxArgs\": 2\n        }\n      },\n      \"browserAction\": {\n        \"disable\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        },\n        \"enable\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        },\n        \"getBadgeBackgroundColor\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getBadgeText\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getPopup\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getTitle\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"openPopup\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"setBadgeBackgroundColor\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        },\n        \"setBadgeText\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        },\n        \"setIcon\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"setPopup\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        },\n        \"setTitle\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        }\n      },\n      \"browsingData\": {\n        \"remove\": {\n          \"minArgs\": 2,\n          \"maxArgs\": 2\n        },\n        \"removeCache\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removeCookies\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removeDownloads\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removeFormData\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removeHistory\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removeLocalStorage\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removePasswords\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removePluginData\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"settings\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        }\n      },\n      \"commands\": {\n        \"getAll\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        }\n      },\n      \"contextMenus\": {\n        \"remove\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removeAll\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"update\": {\n          \"minArgs\": 2,\n          \"maxArgs\": 2\n        }\n      },\n      \"cookies\": {\n        \"get\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getAll\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getAllCookieStores\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"remove\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"set\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        }\n      },\n      \"devtools\": {\n        \"inspectedWindow\": {\n          \"eval\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2,\n            \"singleCallbackArg\": false\n          }\n        },\n        \"panels\": {\n          \"create\": {\n            \"minArgs\": 3,\n            \"maxArgs\": 3,\n            \"singleCallbackArg\": true\n          },\n          \"elements\": {\n            \"createSidebarPane\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            }\n          }\n        }\n      },\n      \"downloads\": {\n        \"cancel\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"download\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"erase\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getFileIcon\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 2\n        },\n        \"open\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        },\n        \"pause\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removeFile\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"resume\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"search\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"show\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        }\n      },\n      \"extension\": {\n        \"isAllowedFileSchemeAccess\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"isAllowedIncognitoAccess\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        }\n      },\n      \"history\": {\n        \"addUrl\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"deleteAll\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"deleteRange\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"deleteUrl\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getVisits\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"search\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        }\n      },\n      \"i18n\": {\n        \"detectLanguage\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getAcceptLanguages\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        }\n      },\n      \"identity\": {\n        \"launchWebAuthFlow\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        }\n      },\n      \"idle\": {\n        \"queryState\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        }\n      },\n      \"management\": {\n        \"get\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getAll\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"getSelf\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"setEnabled\": {\n          \"minArgs\": 2,\n          \"maxArgs\": 2\n        },\n        \"uninstallSelf\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        }\n      },\n      \"notifications\": {\n        \"clear\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"create\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 2\n        },\n        \"getAll\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"getPermissionLevel\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"update\": {\n          \"minArgs\": 2,\n          \"maxArgs\": 2\n        }\n      },\n      \"pageAction\": {\n        \"getPopup\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getTitle\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"hide\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        },\n        \"setIcon\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"setPopup\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        },\n        \"setTitle\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        },\n        \"show\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        }\n      },\n      \"permissions\": {\n        \"contains\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getAll\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"remove\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"request\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        }\n      },\n      \"runtime\": {\n        \"getBackgroundPage\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"getPlatformInfo\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"openOptionsPage\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"requestUpdateCheck\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"sendMessage\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 3\n        },\n        \"sendNativeMessage\": {\n          \"minArgs\": 2,\n          \"maxArgs\": 2\n        },\n        \"setUninstallURL\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        }\n      },\n      \"sessions\": {\n        \"getDevices\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"getRecentlyClosed\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"restore\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        }\n      },\n      \"storage\": {\n        \"local\": {\n          \"clear\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"get\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getBytesInUse\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"set\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"managed\": {\n          \"get\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getBytesInUse\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          }\n        },\n        \"sync\": {\n          \"clear\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"get\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getBytesInUse\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"set\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        }\n      },\n      \"tabs\": {\n        \"captureVisibleTab\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 2\n        },\n        \"create\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"detectLanguage\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"discard\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"duplicate\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"executeScript\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 2\n        },\n        \"get\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getCurrent\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"getZoom\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"getZoomSettings\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"goBack\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"goForward\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"highlight\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"insertCSS\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 2\n        },\n        \"move\": {\n          \"minArgs\": 2,\n          \"maxArgs\": 2\n        },\n        \"query\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"reload\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 2\n        },\n        \"remove\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removeCSS\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 2\n        },\n        \"sendMessage\": {\n          \"minArgs\": 2,\n          \"maxArgs\": 3\n        },\n        \"setZoom\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 2\n        },\n        \"setZoomSettings\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 2\n        },\n        \"update\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 2\n        }\n      },\n      \"topSites\": {\n        \"get\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        }\n      },\n      \"webNavigation\": {\n        \"getAllFrames\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getFrame\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        }\n      },\n      \"webRequest\": {\n        \"handlerBehaviorChanged\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        }\n      },\n      \"windows\": {\n        \"create\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"get\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 2\n        },\n        \"getAll\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"getCurrent\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"getLastFocused\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"remove\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"update\": {\n          \"minArgs\": 2,\n          \"maxArgs\": 2\n        }\n      }\n    };\n\n    if (Object.keys(apiMetadata).length === 0) {\n      throw new Error(\"api-metadata.json has not been included in browser-polyfill\");\n    }\n\n    /**\n     * A WeakMap subclass which creates and stores a value for any key which does\n     * not exist when accessed, but behaves exactly as an ordinary WeakMap\n     * otherwise.\n     *\n     * @param {function} createItem\n     *        A function which will be called in order to create the value for any\n     *        key which does not exist, the first time it is accessed. The\n     *        function receives, as its only argument, the key being created.\n     */\n    class DefaultWeakMap extends WeakMap {\n      constructor(createItem, items = undefined) {\n        super(items);\n        this.createItem = createItem;\n      }\n\n      get(key) {\n        if (!this.has(key)) {\n          this.set(key, this.createItem(key));\n        }\n\n        return super.get(key);\n      }\n    }\n\n    /**\n     * Returns true if the given object is an object with a `then` method, and can\n     * therefore be assumed to behave as a Promise.\n     *\n     * @param {*} value The value to test.\n     * @returns {boolean} True if the value is thenable.\n     */\n    const isThenable = value => {\n      return value && typeof value === \"object\" && typeof value.then === \"function\";\n    };\n\n    /**\n     * Creates and returns a function which, when called, will resolve or reject\n     * the given promise based on how it is called:\n     *\n     * - If, when called, `chrome.runtime.lastError` contains a non-null object,\n     *   the promise is rejected with that value.\n     * - If the function is called with exactly one argument, the promise is\n     *   resolved to that value.\n     * - Otherwise, the promise is resolved to an array containing all of the\n     *   function's arguments.\n     *\n     * @param {object} promise\n     *        An object containing the resolution and rejection functions of a\n     *        promise.\n     * @param {function} promise.resolve\n     *        The promise's resolution function.\n     * @param {function} promise.rejection\n     *        The promise's rejection function.\n     * @param {object} metadata\n     *        Metadata about the wrapped method which has created the callback.\n     * @param {integer} metadata.maxResolvedArgs\n     *        The maximum number of arguments which may be passed to the\n     *        callback created by the wrapped async function.\n     *\n     * @returns {function}\n     *        The generated callback function.\n     */\n    const makeCallback = (promise, metadata) => {\n      return (...callbackArgs) => {\n        if (extensionAPIs.runtime.lastError) {\n          promise.reject(extensionAPIs.runtime.lastError);\n        } else if (metadata.singleCallbackArg ||\n                   (callbackArgs.length <= 1 && metadata.singleCallbackArg !== false)) {\n          promise.resolve(callbackArgs[0]);\n        } else {\n          promise.resolve(callbackArgs);\n        }\n      };\n    };\n\n    const pluralizeArguments = (numArgs) => numArgs == 1 ? \"argument\" : \"arguments\";\n\n    /**\n     * Creates a wrapper function for a method with the given name and metadata.\n     *\n     * @param {string} name\n     *        The name of the method which is being wrapped.\n     * @param {object} metadata\n     *        Metadata about the method being wrapped.\n     * @param {integer} metadata.minArgs\n     *        The minimum number of arguments which must be passed to the\n     *        function. If called with fewer than this number of arguments, the\n     *        wrapper will raise an exception.\n     * @param {integer} metadata.maxArgs\n     *        The maximum number of arguments which may be passed to the\n     *        function. If called with more than this number of arguments, the\n     *        wrapper will raise an exception.\n     * @param {integer} metadata.maxResolvedArgs\n     *        The maximum number of arguments which may be passed to the\n     *        callback created by the wrapped async function.\n     *\n     * @returns {function(object, ...*)}\n     *       The generated wrapper function.\n     */\n    const wrapAsyncFunction = (name, metadata) => {\n      return function asyncFunctionWrapper(target, ...args) {\n        if (args.length < metadata.minArgs) {\n          throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);\n        }\n\n        if (args.length > metadata.maxArgs) {\n          throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);\n        }\n\n        return new Promise((resolve, reject) => {\n          if (metadata.fallbackToNoCallback) {\n            // This API method has currently no callback on Chrome, but it return a promise on Firefox,\n            // and so the polyfill will try to call it with a callback first, and it will fallback\n            // to not passing the callback if the first call fails.\n            try {\n              target[name](...args, makeCallback({resolve, reject}, metadata));\n            } catch (cbError) {\n              console.warn(`${name} API method doesn't seem to support the callback parameter, ` +\n                           \"falling back to call it without a callback: \", cbError);\n\n              target[name](...args);\n\n              // Update the API method metadata, so that the next API calls will not try to\n              // use the unsupported callback anymore.\n              metadata.fallbackToNoCallback = false;\n              metadata.noCallback = true;\n\n              resolve();\n            }\n          } else if (metadata.noCallback) {\n            target[name](...args);\n            resolve();\n          } else {\n            target[name](...args, makeCallback({resolve, reject}, metadata));\n          }\n        });\n      };\n    };\n\n    /**\n     * Wraps an existing method of the target object, so that calls to it are\n     * intercepted by the given wrapper function. The wrapper function receives,\n     * as its first argument, the original `target` object, followed by each of\n     * the arguments passed to the original method.\n     *\n     * @param {object} target\n     *        The original target object that the wrapped method belongs to.\n     * @param {function} method\n     *        The method being wrapped. This is used as the target of the Proxy\n     *        object which is created to wrap the method.\n     * @param {function} wrapper\n     *        The wrapper function which is called in place of a direct invocation\n     *        of the wrapped method.\n     *\n     * @returns {Proxy<function>}\n     *        A Proxy object for the given method, which invokes the given wrapper\n     *        method in its place.\n     */\n    const wrapMethod = (target, method, wrapper) => {\n      return new Proxy(method, {\n        apply(targetMethod, thisObj, args) {\n          return wrapper.call(thisObj, target, ...args);\n        },\n      });\n    };\n\n    let hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);\n\n    /**\n     * Wraps an object in a Proxy which intercepts and wraps certain methods\n     * based on the given `wrappers` and `metadata` objects.\n     *\n     * @param {object} target\n     *        The target object to wrap.\n     *\n     * @param {object} [wrappers = {}]\n     *        An object tree containing wrapper functions for special cases. Any\n     *        function present in this object tree is called in place of the\n     *        method in the same location in the `target` object tree. These\n     *        wrapper methods are invoked as described in {@see wrapMethod}.\n     *\n     * @param {object} [metadata = {}]\n     *        An object tree containing metadata used to automatically generate\n     *        Promise-based wrapper functions for asynchronous. Any function in\n     *        the `target` object tree which has a corresponding metadata object\n     *        in the same location in the `metadata` tree is replaced with an\n     *        automatically-generated wrapper function, as described in\n     *        {@see wrapAsyncFunction}\n     *\n     * @returns {Proxy<object>}\n     */\n    const wrapObject = (target, wrappers = {}, metadata = {}) => {\n      let cache = Object.create(null);\n      let handlers = {\n        has(proxyTarget, prop) {\n          return prop in target || prop in cache;\n        },\n\n        get(proxyTarget, prop, receiver) {\n          if (prop in cache) {\n            return cache[prop];\n          }\n\n          if (!(prop in target)) {\n            return undefined;\n          }\n\n          let value = target[prop];\n\n          if (typeof value === \"function\") {\n            // This is a method on the underlying object. Check if we need to do\n            // any wrapping.\n\n            if (typeof wrappers[prop] === \"function\") {\n              // We have a special-case wrapper for this method.\n              value = wrapMethod(target, target[prop], wrappers[prop]);\n            } else if (hasOwnProperty(metadata, prop)) {\n              // This is an async method that we have metadata for. Create a\n              // Promise wrapper for it.\n              let wrapper = wrapAsyncFunction(prop, metadata[prop]);\n              value = wrapMethod(target, target[prop], wrapper);\n            } else {\n              // This is a method that we don't know or care about. Return the\n              // original method, bound to the underlying object.\n              value = value.bind(target);\n            }\n          } else if (typeof value === \"object\" && value !== null &&\n                     (hasOwnProperty(wrappers, prop) ||\n                      hasOwnProperty(metadata, prop))) {\n            // This is an object that we need to do some wrapping for the children\n            // of. Create a sub-object wrapper for it with the appropriate child\n            // metadata.\n            value = wrapObject(value, wrappers[prop], metadata[prop]);\n          } else if (hasOwnProperty(metadata, \"*\")) {\n            // Wrap all properties in * namespace.\n            value = wrapObject(value, wrappers[prop], metadata[\"*\"]);\n          } else {\n            // We don't need to do any wrapping for this property,\n            // so just forward all access to the underlying object.\n            Object.defineProperty(cache, prop, {\n              configurable: true,\n              enumerable: true,\n              get() {\n                return target[prop];\n              },\n              set(value) {\n                target[prop] = value;\n              },\n            });\n\n            return value;\n          }\n\n          cache[prop] = value;\n          return value;\n        },\n\n        set(proxyTarget, prop, value, receiver) {\n          if (prop in cache) {\n            cache[prop] = value;\n          } else {\n            target[prop] = value;\n          }\n          return true;\n        },\n\n        defineProperty(proxyTarget, prop, desc) {\n          return Reflect.defineProperty(cache, prop, desc);\n        },\n\n        deleteProperty(proxyTarget, prop) {\n          return Reflect.deleteProperty(cache, prop);\n        },\n      };\n\n      // Per contract of the Proxy API, the \"get\" proxy handler must return the\n      // original value of the target if that value is declared read-only and\n      // non-configurable. For this reason, we create an object with the\n      // prototype set to `target` instead of using `target` directly.\n      // Otherwise we cannot return a custom object for APIs that\n      // are declared read-only and non-configurable, such as `chrome.devtools`.\n      //\n      // The proxy handlers themselves will still use the original `target`\n      // instead of the `proxyTarget`, so that the methods and properties are\n      // dereferenced via the original targets.\n      let proxyTarget = Object.create(target);\n      return new Proxy(proxyTarget, handlers);\n    };\n\n    /**\n     * Creates a set of wrapper functions for an event object, which handles\n     * wrapping of listener functions that those messages are passed.\n     *\n     * A single wrapper is created for each listener function, and stored in a\n     * map. Subsequent calls to `addListener`, `hasListener`, or `removeListener`\n     * retrieve the original wrapper, so that  attempts to remove a\n     * previously-added listener work as expected.\n     *\n     * @param {DefaultWeakMap<function, function>} wrapperMap\n     *        A DefaultWeakMap object which will create the appropriate wrapper\n     *        for a given listener function when one does not exist, and retrieve\n     *        an existing one when it does.\n     *\n     * @returns {object}\n     */\n    const wrapEvent = wrapperMap => ({\n      addListener(target, listener, ...args) {\n        target.addListener(wrapperMap.get(listener), ...args);\n      },\n\n      hasListener(target, listener) {\n        return target.hasListener(wrapperMap.get(listener));\n      },\n\n      removeListener(target, listener) {\n        target.removeListener(wrapperMap.get(listener));\n      },\n    });\n\n    // Keep track if the deprecation warning has been logged at least once.\n    let loggedSendResponseDeprecationWarning = false;\n\n    const onMessageWrappers = new DefaultWeakMap(listener => {\n      if (typeof listener !== \"function\") {\n        return listener;\n      }\n\n      /**\n       * Wraps a message listener function so that it may send responses based on\n       * its return value, rather than by returning a sentinel value and calling a\n       * callback. If the listener function returns a Promise, the response is\n       * sent when the promise either resolves or rejects.\n       *\n       * @param {*} message\n       *        The message sent by the other end of the channel.\n       * @param {object} sender\n       *        Details about the sender of the message.\n       * @param {function(*)} sendResponse\n       *        A callback which, when called with an arbitrary argument, sends\n       *        that value as a response.\n       * @returns {boolean}\n       *        True if the wrapped listener returned a Promise, which will later\n       *        yield a response. False otherwise.\n       */\n      return function onMessage(message, sender, sendResponse) {\n        let didCallSendResponse = false;\n\n        let wrappedSendResponse;\n        let sendResponsePromise = new Promise(resolve => {\n          wrappedSendResponse = function(response) {\n            if (!loggedSendResponseDeprecationWarning) {\n              console.warn(SEND_RESPONSE_DEPRECATION_WARNING, new Error().stack);\n              loggedSendResponseDeprecationWarning = true;\n            }\n            didCallSendResponse = true;\n            resolve(response);\n          };\n        });\n\n        let result;\n        try {\n          result = listener(message, sender, wrappedSendResponse);\n        } catch (err) {\n          result = Promise.reject(err);\n        }\n\n        const isResultThenable = result !== true && isThenable(result);\n\n        // If the listener didn't returned true or a Promise, or called\n        // wrappedSendResponse synchronously, we can exit earlier\n        // because there will be no response sent from this listener.\n        if (result !== true && !isResultThenable && !didCallSendResponse) {\n          return false;\n        }\n\n        // A small helper to send the message if the promise resolves\n        // and an error if the promise rejects (a wrapped sendMessage has\n        // to translate the message into a resolved promise or a rejected\n        // promise).\n        const sendPromisedResult = (promise) => {\n          promise.then(msg => {\n            // send the message value.\n            sendResponse(msg);\n          }, error => {\n            // Send a JSON representation of the error if the rejected value\n            // is an instance of error, or the object itself otherwise.\n            let message;\n            if (error && (error instanceof Error ||\n                typeof error.message === \"string\")) {\n              message = error.message;\n            } else {\n              message = \"An unexpected error occurred\";\n            }\n\n            sendResponse({\n              __mozWebExtensionPolyfillReject__: true,\n              message,\n            });\n          }).catch(err => {\n            // Print an error on the console if unable to send the response.\n            console.error(\"Failed to send onMessage rejected reply\", err);\n          });\n        };\n\n        // If the listener returned a Promise, send the resolved value as a\n        // result, otherwise wait the promise related to the wrappedSendResponse\n        // callback to resolve and send it as a response.\n        if (isResultThenable) {\n          sendPromisedResult(result);\n        } else {\n          sendPromisedResult(sendResponsePromise);\n        }\n\n        // Let Chrome know that the listener is replying.\n        return true;\n      };\n    });\n\n    const wrappedSendMessageCallback = ({reject, resolve}, reply) => {\n      if (extensionAPIs.runtime.lastError) {\n        // Detect when none of the listeners replied to the sendMessage call and resolve\n        // the promise to undefined as in Firefox.\n        // See https://github.com/mozilla/webextension-polyfill/issues/130\n        if (extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) {\n          resolve();\n        } else {\n          reject(extensionAPIs.runtime.lastError);\n        }\n      } else if (reply && reply.__mozWebExtensionPolyfillReject__) {\n        // Convert back the JSON representation of the error into\n        // an Error instance.\n        reject(new Error(reply.message));\n      } else {\n        resolve(reply);\n      }\n    };\n\n    const wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {\n      if (args.length < metadata.minArgs) {\n        throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);\n      }\n\n      if (args.length > metadata.maxArgs) {\n        throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);\n      }\n\n      return new Promise((resolve, reject) => {\n        const wrappedCb = wrappedSendMessageCallback.bind(null, {resolve, reject});\n        args.push(wrappedCb);\n        apiNamespaceObj.sendMessage(...args);\n      });\n    };\n\n    const staticWrappers = {\n      runtime: {\n        onMessage: wrapEvent(onMessageWrappers),\n        onMessageExternal: wrapEvent(onMessageWrappers),\n        sendMessage: wrappedSendMessage.bind(null, \"sendMessage\", {minArgs: 1, maxArgs: 3}),\n      },\n      tabs: {\n        sendMessage: wrappedSendMessage.bind(null, \"sendMessage\", {minArgs: 2, maxArgs: 3}),\n      },\n    };\n    const settingMetadata = {\n      clear: {minArgs: 1, maxArgs: 1},\n      get: {minArgs: 1, maxArgs: 1},\n      set: {minArgs: 1, maxArgs: 1},\n    };\n    apiMetadata.privacy = {\n      network: {\"*\": settingMetadata},\n      services: {\"*\": settingMetadata},\n      websites: {\"*\": settingMetadata},\n    };\n\n    return wrapObject(extensionAPIs, staticWrappers, apiMetadata);\n  };\n\n  if (typeof chrome != \"object\" || !chrome || !chrome.runtime || !chrome.runtime.id) {\n    throw new Error(\"This script should only be loaded in a browser extension.\");\n  }\n\n  // The build process adds a UMD wrapper around this file, which makes the\n  // `module` variable available.\n  module.exports = wrapAPIs(chrome);\n} else {\n  module.exports = browser;\n}\n","import {\n    ZProxyWS,\n    PointType,\n    PromisedValue,\n    URLSearchQuery,\n    ZProxyWSOptions,\n    StorageGetRequest,\n    StoragePutStringRequest,\n    OwnerToIdentityRequest,\n    SubscriptionErrors,\n    MessageQueueConfig,\n    ContractLoadRequest,\n    ContractCallRequest,\n    ContractSendRequest,\n    SubscriptionMessages,\n    SubscriptionEvent,\n    SubscriptionParams,\n} from \"./index.d\";\n\n// Find a better way to handle this or move this to a different constants file or create a getter/setter method to set this variable in a class\nlet walletAccess = false;\n\nexport default (host: string, version: string): PointType => {\n    class PointSDKRequestError extends Error {}\n    class MessageQueueOverflow extends Error {}\n    class ZProxyWSConnectionError extends Error {}\n    class ZProxyWSConnectionClosed extends Error {}\n    class SubscriptionRequestTimeout extends Error {}\n    class SubscriptionError extends Error {}\n\n    // const getAuthHeaders = () => ({ Authorization: 'Basic ' + btoa('WALLETID-PASSCODE') });\n    const getAuthHeaders = (): HeadersInit => ({\n        \"wallet-token\": \"WALLETID-PASSCODE\",\n    });\n\n    const apiCall = async <T>(path: string, config?: RequestInit) => {\n        try {\n            // @ts-ignore, https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content_scripts#xhr_and_fetch\n            const response = await window.top.fetch(`${host}/v1/api/${path}`, {\n                cache: \"no-cache\",\n                credentials: \"include\",\n                keepalive: true,\n                ...config,\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...config?.headers,\n                },\n            });\n\n            if (!response.ok) {\n                const { ok, status, statusText, headers } = response;\n                console.error(\"SDK call failed:\", {\n                    // @ts-ignore\n                    ok,\n                    status,\n                    statusText,\n                    headers: Object.fromEntries([...headers.entries()]),\n                });\n                throw new PointSDKRequestError(\"Point SDK request failed\");\n            }\n\n            try {\n                return (await response.json()) as T;\n            } catch (e) {\n                console.error(\"Point API response parsing error:\", e);\n                throw e;\n            }\n        } catch (e) {\n            console.error(\"Point API call failed:\", e);\n            throw e;\n        }\n    };\n\n    const zproxyStorageCall = async <T>(path: string, config?: RequestInit) => {\n        try {\n            // @ts-ignore, https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content_scripts#xhr_and_fetch\n            const response = await window.top.fetch(`${host}/${path}`, {\n                cache: \"no-cache\",\n                credentials: \"include\",\n                keepalive: true,\n                ...config,\n                //\n            });\n\n            if (!response.ok) {\n                const { ok, status, statusText, headers } = response;\n                console.error(\"SDK ZProxy call failed:\", {\n                    // @ts-ignore\n                    ok,\n                    status,\n                    statusText,\n                    headers: Object.fromEntries([...headers.entries()]),\n                });\n                throw new PointSDKRequestError(\"Point SDK request failed\");\n            }\n\n            try {\n                return (await response.json()) as T;\n            } catch (e) {\n                console.error(\"Point API response parsing error:\", e);\n                throw e;\n            }\n        } catch (e) {\n            console.error(\"Point API call failed:\", e);\n            throw e;\n        }\n    };\n\n    const api = {\n        get<T>(\n            pathname: string,\n            query?: URLSearchQuery,\n            headers?: HeadersInit,\n        ): Promise<T> {\n            return apiCall<T>(\n                `${pathname}${query ? \"?\" : \"\"}${new URLSearchParams(\n                    query,\n                ).toString()}`,\n                {\n                    method: \"GET\",\n                    headers,\n                },\n            );\n        },\n        post<T>(\n            pathname: string,\n            body: any,\n            headers?: HeadersInit,\n        ): Promise<T> {\n            return apiCall<T>(pathname, {\n                method: \"POST\",\n                headers,\n                body: JSON.stringify(body),\n            });\n        },\n        postFile<T>(pathname: string, file: FormData): Promise<T> {\n            return zproxyStorageCall<T>(pathname, {\n                method: \"POST\",\n                body: file,\n                // headers NOT required when passing FormData object\n            });\n        },\n    };\n\n    function sleep(ms: number): Promise<undefined> {\n        return new Promise((resolve) => setTimeout(resolve, ms));\n    }\n\n    function Promised<T>(): PromisedValue<T> {\n        let resolve = (() => {}) as (value: T | PromiseLike<T>) => void;\n        let reject = (() => {}) as (reason: Error | string | undefined) => void;\n\n        return Object.assign(\n            new Promise<T>((_resolve, _reject) => {\n                resolve = _resolve;\n                reject = _reject;\n            }),\n            {\n                resolve,\n                reject,\n            },\n        );\n    }\n\n    function SubscriptionTimeout(ms: number): Promise<undefined> {\n        return new Promise((_, reject) =>\n            setTimeout(\n                () =>\n                    reject(\n                        new SubscriptionRequestTimeout(\n                            \"Subscription confirmation timeout\",\n                        ),\n                    ),\n                ms,\n            ),\n        );\n    }\n\n    const socketsByHost: Record<string, WebSocket> = {};\n    const messagesBySubscriptionId: SubscriptionMessages = {};\n    const errorsBySubscriptionId: SubscriptionErrors = {};\n\n    const SUBSCRIPTION_EVENT_TYPES = {\n        CONFIRMATION: \"subscription_confirmation\",\n        CANCELLATION: \"subscription_cancellation\",\n        EVENT: \"subscription_event\",\n        ERROR: \"subscription_error\",\n    };\n\n    const SUBSCRIPTION_REQUEST_TYPES = {\n        SUBSCRIBE: \"subscribeContractEvent\",\n        UNSUBSCRIBE: \"removeSubscriptionById\",\n    };\n\n    const getSubscriptionRequestId = ({\n        type,\n        params: { contract, event } = {},\n    }: MessageQueueConfig) => `${type}_${contract}_${event}`;\n\n    const getMessageQueue = <T>(subscriptionId: string): T[] =>\n        messagesBySubscriptionId[subscriptionId] ||\n        (messagesBySubscriptionId[subscriptionId] = []);\n\n    const subscriptionIdsByRequestId: Record<string, PromisedValue<string>> =\n        {};\n\n    const wsConnect = (\n        host: string,\n        { messageQueueSizeLimit = 1000 } = {} as ZProxyWSOptions,\n    ): Promise<ZProxyWS | undefined> =>\n        new Promise((resolve, reject) => {\n            if (socketsByHost[host] !== undefined) {\n                resolve(socketsByHost[host] as ZProxyWS);\n                return;\n            }\n\n            const ws = new WebSocket(host);\n\n            ws.onopen = () =>\n                resolve(\n                    Object.assign((socketsByHost[host] = ws), {\n                        async subscribeToContractEvent<T>(\n                            params: SubscriptionParams,\n                        ): Promise<() => Promise<T>> {\n                            const metaData = {\n                                type: SUBSCRIPTION_REQUEST_TYPES.SUBSCRIBE,\n                                params,\n                            };\n                            const requestId =\n                                getSubscriptionRequestId(metaData);\n\n                            subscriptionIdsByRequestId[requestId] =\n                                Promised<string>();\n\n                            await ws.send(JSON.stringify(metaData));\n\n                            const subscriptionId = (await Promise.race([\n                                subscriptionIdsByRequestId[requestId],\n                                SubscriptionTimeout(10000),\n                            ])) as string;\n\n                            const queue = getMessageQueue<T>(subscriptionId);\n\n                            return Object.assign(\n                                async (): Promise<T> => {\n                                    while (true) {\n                                        try {\n                                            const queueError =\n                                                errorsBySubscriptionId[\n                                                    subscriptionId\n                                                ];\n                                            if (queueError) {\n                                                throw queueError;\n                                            }\n                                            if (queue.length) {\n                                                return queue.shift() as T;\n                                            } else {\n                                                await sleep(100);\n                                            }\n                                        } catch (e) {\n                                            console.error(\n                                                \"subscribed message error:\",\n                                                e,\n                                            );\n                                            throw e;\n                                        }\n                                    }\n                                },\n                                {\n                                    unsubscribe() {\n                                        return ws.send(\n                                            JSON.stringify({\n                                                type: SUBSCRIPTION_REQUEST_TYPES.UNSUBSCRIBE,\n                                                params: { subscriptionId },\n                                            }),\n                                        );\n                                    },\n                                },\n                            );\n                        },\n                    }) as ZProxyWS,\n                );\n\n            ws.onerror = (e) => {\n                for (const queueId in messagesBySubscriptionId) {\n                    if (!errorsBySubscriptionId[queueId]) {\n                        errorsBySubscriptionId[queueId] =\n                            new ZProxyWSConnectionError(e.toString());\n                    }\n                }\n            };\n\n            ws.onclose = (e) => {\n                delete socketsByHost[host];\n\n                for (const queueId in messagesBySubscriptionId) {\n                    if (!errorsBySubscriptionId[queueId]) {\n                        errorsBySubscriptionId[queueId] =\n                            new ZProxyWSConnectionClosed(e.toString());\n                    }\n                }\n\n                if (e.code === 1000) {\n                    resolve(undefined); // closed intentionally\n                } else {\n                    reject();\n                }\n            };\n\n            ws.onmessage = (e) => {\n                try {\n                    const {\n                        type,\n                        request,\n                        subscriptionId,\n                        data,\n                    }: SubscriptionEvent<unknown> = JSON.parse(e.data);\n\n                    switch (type) {\n                        case SUBSCRIPTION_EVENT_TYPES.CONFIRMATION: {\n                            const requestId = getSubscriptionRequestId(request);\n                            const { resolve, reject } =\n                                subscriptionIdsByRequestId[requestId] || {};\n\n                            if (typeof subscriptionId !== \"string\") {\n                                if (typeof reject === \"function\") {\n                                    reject(\n                                        new SubscriptionError(\n                                            `Invalid subscription id \"${subscriptionId}\" for request id: \"${requestId}\"`,\n                                        ),\n                                    );\n                                }\n                            } else if (typeof resolve === \"function\") {\n                                resolve(subscriptionId);\n                            }\n                            break;\n                        }\n\n                        case SUBSCRIPTION_EVENT_TYPES.CANCELLATION: {\n                            if (subscriptionId) {\n                                console.info({\n                                    type,\n                                    request,\n                                    subscriptionId,\n                                    data,\n                                });\n\n                                delete messagesBySubscriptionId[subscriptionId];\n                                delete errorsBySubscriptionId[subscriptionId];\n                            }\n                            break;\n                        }\n\n                        case SUBSCRIPTION_EVENT_TYPES.EVENT: {\n                            if (subscriptionId) {\n                                const queue = getMessageQueue(subscriptionId);\n\n                                if (queue.length > messageQueueSizeLimit) {\n                                    errorsBySubscriptionId[subscriptionId] =\n                                        new MessageQueueOverflow(\n                                            \"ZProxy WS message queue overflow\",\n                                        );\n                                } else {\n                                    queue.push(data);\n                                }\n                            } else {\n                                console.error(\n                                    \"Unable to identify subscription channel\",\n                                    {\n                                        subscriptionId,\n                                        request,\n                                        data,\n                                    },\n                                );\n                            }\n                            break;\n                        }\n\n                        case SUBSCRIPTION_EVENT_TYPES.ERROR: {\n                            if (subscriptionId) {\n                                errorsBySubscriptionId[subscriptionId] =\n                                    new SubscriptionError(JSON.stringify(data));\n                            } else {\n                                console.error(\n                                    \"Unable to identify subscription channel\",\n                                    {\n                                        subscriptionId,\n                                        request,\n                                        data,\n                                    },\n                                );\n                            }\n                            break;\n                        }\n\n                        default: {\n                            console.error(\"Unsupported event type:\", {\n                                type,\n                                request,\n                                subscriptionId,\n                                data,\n                            });\n                        }\n                    }\n                } catch (e) {\n                    console.log(\"Web Socket onmessage error:\", e);\n                }\n            };\n        });\n\n    return {\n        version: version,\n        status: {\n            ping: () =>\n                api.get<\"pong\">(\"status/ping\", undefined, getAuthHeaders()),\n        },\n        contract: {\n            load: <T>({ contract, ...args }: ContractLoadRequest) =>\n                api.get<T>(`contract/load/${contract}`, args, getAuthHeaders()),\n            call: <T>(args: ContractCallRequest) =>\n                api.post<T>(\"contract/call\", args, getAuthHeaders()),\n            send: <T>(args: ContractSendRequest) => {\n                // This is a sample approach which uses the native window dialogs to alert the user of the send transaction happening\n                const choice = window.confirm(\n                    `This site is trying to send a transaction for the ${args.method} method for the ${args.contract} contract. Allow this action?`,\n                );\n                if (!choice) {\n                    alert(\"Transaction not sent\");\n                    throw new Error(\"Send method not allowed\");\n                }\n                if (!walletAccess) {\n                    alert(\"Wallet access denied\");\n                    throw new Error(\"Wallet access denied\");\n                }\n                return api.post<T>(\"contract/send\", args, getAuthHeaders());\n            },\n            async subscribe<T>({\n                contract,\n                event,\n                ...options\n            }: SubscriptionParams) {\n                if (typeof contract !== \"string\") {\n                    throw new PointSDKRequestError(\n                        `Invalid contract ${contract}`,\n                    );\n                }\n                if (typeof event !== \"string\") {\n                    throw new PointSDKRequestError(`Invalid event ${event}`);\n                }\n\n                const url = new URL(host);\n                url.protocol = url.protocol === \"https:\" ? \"wss:\" : \"ws:\";\n                const socket = await wsConnect(url.toString());\n\n                if (!socket) {\n                    throw new PointSDKRequestError(\n                        \"Failed to establish web socket connection\",\n                    );\n                }\n\n                return socket.subscribeToContractEvent<T>({\n                    contract,\n                    event,\n                    ...options,\n                });\n            },\n        },\n        storage: {\n            postFile: <T>(file: FormData) => api.postFile<T>(\"_storage/\", file),\n            getString: <T>({ id, ...args }: StorageGetRequest) =>\n                api.get<T>(`storage/getString/${id}`, args, getAuthHeaders()),\n            putString: <T>(data: StoragePutStringRequest) =>\n                api.post<T>(\"storage/putString\", data, getAuthHeaders()),\n        },\n        wallet: {\n            address: () => {\n                // This is a sample approach which uses the native window dialogs to alert the user of the site trying to access wallet address\n                // In the future, the idea should be that in the local point node, we save whether the user has granted the visited site access to their wallet address or not.\n                // Then when the user visits the site again, we check if access is already given or not, if yes then we allow the site to access the wallet address when it requests it, else we prevent that from happening with perhaps an appropriate dialog. Same goes for the send transaction methods\n                const choice = window.confirm(\n                    \"Allow the site to access your wallet address?\",\n                );\n                if (!choice) {\n                    walletAccess = false;\n                    alert(\"Wallet access denied\");\n                    throw new Error(\"Wallet access denied\");\n                }\n                walletAccess = true;\n                window.alert(\"This site has access to your wallet address now\");\n                return api.get<string>(\"wallet/address\");\n            },\n            hash: () => api.get<string>(\"wallet/hash\"),\n        },\n        identity: {\n            ownerToIdentity: <T>({ owner, ...args }: OwnerToIdentityRequest) =>\n                api.get<T>(\n                    `identity/ownerToIdentity/${owner}`,\n                    args,\n                    getAuthHeaders(),\n                ),\n        },\n    };\n};\n","// @ts-ignore\nimport polyfill from \"webextension-polyfill\";\n\nglobal.browser = polyfill;\n\nimport point from \"pointsdk/pointsdk\";\n\nconst version = browser.runtime.getManifest().version;\n\nwindow.eval(`window.point = (${point.toString()})(window.location.origin, '${version}');`);\n"],"names":["browser","Object","getPrototypeOf","prototype","CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE","SEND_RESPONSE_DEPRECATION_WARNING","wrapAPIs","extensionAPIs","apiMetadata","keys","length","Error","DefaultWeakMap","WeakMap","createItem","items","super","get","key","has","this","set","makeCallback","promise","metadata","callbackArgs","runtime","lastError","reject","singleCallbackArg","resolve","pluralizeArguments","numArgs","wrapMethod","target","method","wrapper","Proxy","apply","targetMethod","thisObj","args","call","hasOwnProperty","Function","bind","wrapObject","wrappers","cache","create","handlers","proxyTarget","prop","receiver","value","name","minArgs","maxArgs","Promise","fallbackToNoCallback","cbError","console","warn","noCallback","wrapAsyncFunction","defineProperty","configurable","enumerable","desc","Reflect","deleteProperty","wrapEvent","wrapperMap","addListener","listener","hasListener","removeListener","loggedSendResponseDeprecationWarning","onMessageWrappers","message","sender","sendResponse","wrappedSendResponse","result","didCallSendResponse","sendResponsePromise","response","stack","err","isResultThenable","then","sendPromisedResult","msg","error","__mozWebExtensionPolyfillReject__","catch","wrappedSendMessageCallback","reply","wrappedSendMessage","apiNamespaceObj","wrappedCb","push","sendMessage","staticWrappers","onMessage","onMessageExternal","tabs","settingMetadata","clear","privacy","network","services","websites","chrome","id","module","exports","$37c372170ff1ffa56925e2f9aa26f186$var$walletAccess","$parcel$global","$parcel$interopDefault","$4KHtv","$fe6805ae6a1acc57369ff96015183e28$var$version","getManifest","version","window","eval","host","PointSDKRequestError","MessageQueueOverflow","ZProxyWSConnectionError","ZProxyWSConnectionClosed","SubscriptionRequestTimeout","SubscriptionError","apiCall","async","path","config","top","fetch","credentials","keepalive","headers","ok","status","statusText","fromEntries","entries","json","e","api","pathname","query","URLSearchParams","toString","post","body","JSON","stringify","postFile","file","zproxyStorageCall","sleep","ms","setTimeout","socketsByHost","messagesBySubscriptionId","errorsBySubscriptionId","SUBSCRIPTION_EVENT_TYPES","SUBSCRIPTION_REQUEST_TYPES","getSubscriptionRequestId","type","params","contract","event","getMessageQueue","subscriptionId","subscriptionIdsByRequestId","wsConnect","host1","messageQueueSizeLimit","undefined","ws","WebSocket","onopen","assign","metaData","requestId","_resolve","_reject","Promised","send","race","_","queue","queueError","shift","unsubscribe","onerror","queueId","onclose","code","onmessage","request","data","parse","resolve1","reject1","info","e1","log","ping","load","confirm","alert","options","url","URL","protocol","socket","subscribeToContractEvent","storage","getString","putString","wallet","address","hash","identity","ownerToIdentity","owner"],"version":3,"file":"index.js.map"}